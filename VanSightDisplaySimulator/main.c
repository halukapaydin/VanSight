/**
 * @file main.c
 * VanSight Display Simulator - PC Simulator for VanSightDisplayClient
 * 
 * This simulator allows you to visualize and test the VanSight UI
 * without ESP32 hardware using SDL2.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include "lvgl/lvgl.h"
#include "lv_drivers/sdl/sdl.h"
#include "ui/src/ui.h"
#include "ui_event_handlers.h"
#include "espnow_stub.h"

/* Display resolution */
#define HOR_RES 800
#define VER_RES 480

/* LVGL tick period in milliseconds */
#define TICK_PERIOD_MS 5

static void hal_init(void);
static uint32_t millis_get(void);
static void tick_update(void);

/* Global tick tracking variable */
static uint32_t last_tick = 0;

int main(int argc, char **argv)
{
    (void)argc;
    (void)argv;

    printf("VanSight Display Simulator\n");
    printf("==========================\n");
    printf("Resolution: %dx%d\n", HOR_RES, VER_RES);
    printf("LVGL Version: %d.%d.%d\n\n", 
           lv_version_major(), lv_version_minor(), lv_version_patch());

    /* Initialize LVGL */
    lv_init();

    /* Initialize HAL (display and input devices) */
    hal_init();

    /* Initialize the UI (generated by SquareLine Studio) */
    ui_init();
    
    /* Initialize ESP-NOW stub */
    printf("\nInitializing ESP-NOW stub...\n");
    esp_now_init();
    
    /* Add dummy peer */
    esp_now_peer_info_t peer = {0};
    peer.peer_addr[0] = 0xFF;
    peer.peer_addr[1] = 0xFF;
    peer.peer_addr[2] = 0xFF;
    peer.peer_addr[3] = 0xFF;
    peer.peer_addr[4] = 0xFF;
    peer.peer_addr[5] = 0xFF;
    esp_now_add_peer(&peer);
    
    /* Register ESP-NOW receive callback for UI updates */
    esp_now_register_recv_cb(NULL);  // Stub handles UI updates internally
    
    printf("ESP-NOW stub initialized!\n\n");

    printf("Simulator started successfully!\n");
    printf("Close the window or press Ctrl+C to exit.\n\n");

    /* Main loop */
    while(1) {
        /* Update LVGL tick */
        tick_update();
        
        /* Handle LVGL tasks */
        uint32_t time_till_next = lv_timer_handler();
        
        /* Sleep for a short time */
        usleep(time_till_next * 1000);
    }

    return 0;
}

/**
 * Initialize the Hardware Abstraction Layer (HAL) for LVGL
 * Sets up display and input device drivers
 */
static void hal_init(void)
{
    /* Initialize SDL */
    sdl_init();

    /* Create a display buffer */
    static lv_disp_draw_buf_t disp_buf;
    static lv_color_t buf1[HOR_RES * 100];
    lv_disp_draw_buf_init(&disp_buf, buf1, NULL, HOR_RES * 100);

    /* Create and register the display driver */
    static lv_disp_drv_t disp_drv;
    lv_disp_drv_init(&disp_drv);
    disp_drv.draw_buf = &disp_buf;
    disp_drv.flush_cb = sdl_display_flush;
    disp_drv.hor_res = HOR_RES;
    disp_drv.ver_res = VER_RES;
    lv_disp_drv_register(&disp_drv);

    /* Create and register mouse (touchscreen) input device driver */
    static lv_indev_drv_t indev_drv;
    lv_indev_drv_init(&indev_drv);
    indev_drv.type = LV_INDEV_TYPE_POINTER;
    indev_drv.read_cb = sdl_mouse_read;
    lv_indev_drv_register(&indev_drv);

    /* Create and register keyboard input device driver */
    static lv_indev_drv_t indev_drv_kb;
    lv_indev_drv_init(&indev_drv_kb);
    indev_drv_kb.type = LV_INDEV_TYPE_KEYPAD;
    indev_drv_kb.read_cb = sdl_keyboard_read;
    lv_indev_drv_register(&indev_drv_kb);
    
    /* Initialize tick tracking */
    last_tick = millis_get();
}

/**
 * Get the current time in milliseconds
 * Used as a tick source for LVGL
 */
static uint32_t millis_get(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
}

/**
 * Update LVGL tick
 */
static void tick_update(void)
{
    uint32_t now = millis_get();
    uint32_t elapsed = now - last_tick;
    last_tick = now;
    lv_tick_inc(elapsed);
}
